From 447d51c2e07eeb7353c3b4f620e350569067a1b0 Mon Sep 17 00:00:00 2001
From: wangmengqiang <wangmengqiang001@126.com>
Date: Sun, 27 Sep 2020 15:48:05 +0800
Subject: [PATCH] fix cve-2020-5421 on v3.1.1.RELEASE

Signed-off-by: wangmengqiang <wangmengqiang001@126.com>
---
 .../AbstractMessageConverterMethodProcessor.java   |  90 ++-
 .../springframework/web/util/UrlPathHelper.java    | 888 +++++++++++----------
 2 files changed, 576 insertions(+), 402 deletions(-)

diff --git a/org.springframework.web.servlet/src/main/java/org/springframework/web/servlet/mvc/method/annotation/AbstractMessageConverterMethodProcessor.java b/org.springframework.web.servlet/src/main/java/org/springframework/web/servlet/mvc/method/annotation/AbstractMessageConverterMethodProcessor.java
index b111c58..bc3ad78 100644
--- a/org.springframework.web.servlet/src/main/java/org/springframework/web/servlet/mvc/method/annotation/AbstractMessageConverterMethodProcessor.java
+++ b/org.springframework.web.servlet/src/main/java/org/springframework/web/servlet/mvc/method/annotation/AbstractMessageConverterMethodProcessor.java
@@ -18,16 +18,20 @@ package org.springframework.web.servlet.mvc.method.annotation;
 
 import java.io.IOException;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Collections;
+import java.util.HashSet;
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
+import java.util.Locale;
 
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
 
 import org.springframework.core.MethodParameter;
+import org.springframework.http.HttpHeaders;
 import org.springframework.http.HttpInputMessage;
 import org.springframework.http.HttpOutputMessage;
 import org.springframework.http.MediaType;
@@ -39,6 +43,8 @@ import org.springframework.web.HttpMediaTypeNotAcceptableException;
 import org.springframework.web.context.request.NativeWebRequest;
 import org.springframework.web.method.support.HandlerMethodReturnValueHandler;
 import org.springframework.web.servlet.HandlerMapping;
+import org.springframework.web.util.UrlPathHelper;
+import org.springframework.util.StringUtils;
 
 /**
  * Extends {@link AbstractMessageConverterMethodArgumentResolver} with the ability to handle method return 
@@ -52,9 +58,26 @@ public abstract class AbstractMessageConverterMethodProcessor extends AbstractMe
 		implements HandlerMethodReturnValueHandler {
 
 	private static final MediaType MEDIA_TYPE_APPLICATION = new MediaType("application");
-
+	//20200921
+	private static final UrlPathHelper RAW_URL_PATH_HELPER = new UrlPathHelper();
+	//20200921
+	private static final UrlPathHelper DECODING_URL_PATH_HELPER = new UrlPathHelper();
+	//20200921
+	static {
+		RAW_URL_PATH_HELPER.setRemoveSemicolonContent(false);
+		RAW_URL_PATH_HELPER.setUrlDecode(false);
+	}
+	//20200921
+	/* Extensions associated with the built-in message converters */
+	private static final Set<String> WHITELISTED_EXTENSIONS = new HashSet<String>(Arrays.asList(
+			"txt", "text", "json", "xml", "atom", "rss", "png", "jpe", "jpeg", "jpg", "gif", "wbmp", "bmp"));
+	//20200921
+	private final Set<String> safeExtensions = new HashSet<String>();
+	
 	protected AbstractMessageConverterMethodProcessor(List<HttpMessageConverter<?>> messageConverters) {
 		super(messageConverters);
+		//20200921
+		this.safeExtensions.addAll(WHITELISTED_EXTENSIONS);
 	}
 
 	/**
@@ -134,6 +157,8 @@ public abstract class AbstractMessageConverterMethodProcessor extends AbstractMe
 		if (selectedMediaType != null) {
 			for (HttpMessageConverter<?> messageConverter : messageConverters) {
 				if (messageConverter.canWrite(returnValueClass, selectedMediaType)) {
+					//20200921
+					addContentDispositionHeader(inputMessage, outputMessage);
 					((HttpMessageConverter<T>) messageConverter).write(returnValue, selectedMediaType, outputMessage);
 					if (logger.isDebugEnabled()) {
 						logger.debug("Written [" + returnValue + "] as \"" + selectedMediaType + "\" using [" +
@@ -189,5 +214,66 @@ public abstract class AbstractMessageConverterMethodProcessor extends AbstractMe
 		MediaType t2 = new MediaType(type2, params);
 		return MediaType.SPECIFICITY_COMPARATOR.compare(t1, t2) <= 0 ? type1 : type2;
 	}
+	//20200921
+	/**
+	 * Check if the path has a file extension and whether the extension is either
+	 * {@link #WHITELISTED_EXTENSIONS whitelisted} or
+	 * {@link ContentNegotiationManager#getAllFileExtensions() explicitly
+	 * registered}. If not add a 'Content-Disposition' header with a safe
+	 * attachment file name ("f.txt") to prevent RFD exploits.
+	 */
+	private void addContentDispositionHeader(ServletServerHttpRequest request,
+			ServletServerHttpResponse response) {
+
+		HttpHeaders headers = response.getHeaders();
+		if (headers.containsKey("Content-Disposition")) {
+			return;
+		}
+
+		HttpServletRequest servletRequest = request.getServletRequest();
+		String requestUri = RAW_URL_PATH_HELPER.getOriginatingRequestUri(servletRequest);
+
+		int index = requestUri.lastIndexOf('/') + 1;
+		String filename = requestUri.substring(index);
+		String pathParams = "";
+
+		index = filename.indexOf(';');
+		if (index != -1) {
+			pathParams = filename.substring(index);
+			filename = filename.substring(0, index);
+		}
+
+		filename = DECODING_URL_PATH_HELPER.decodeRequestString(servletRequest, filename);
+		String ext = StringUtils.getFilenameExtension(filename);
 
-}
\ No newline at end of file
+		pathParams = DECODING_URL_PATH_HELPER.decodeRequestString(servletRequest, pathParams);
+		String extInPathParams = StringUtils.getFilenameExtension(pathParams);
+
+		if (!safeExtension(servletRequest, ext) || !safeExtension(servletRequest, extInPathParams)) {
+			headers.add("Content-Disposition", "inline;filename=f.txt");
+		}
+	}
+	//20200921
+	@SuppressWarnings("unchecked")
+	private boolean safeExtension(HttpServletRequest request, String extension) {
+		if (!StringUtils.hasText(extension)) {
+			return true;
+		}
+		extension = extension.toLowerCase(Locale.ENGLISH);
+		if (this.safeExtensions.contains(extension)) {
+			return true;
+		}
+		String pattern = (String) request.getAttribute(HandlerMapping.BEST_MATCHING_PATTERN_ATTRIBUTE);
+		if (pattern != null && pattern.endsWith("." + extension)) {
+			return true;
+		}
+		if (extension.equals("html")) {
+			String name = HandlerMapping.PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE;
+			Set<MediaType> mediaTypes = (Set<MediaType>) request.getAttribute(name);
+			if (!CollectionUtils.isEmpty(mediaTypes) && mediaTypes.contains(MediaType.TEXT_HTML)) {
+				return true;
+			}
+		}
+		return false;
+	}
+}
diff --git a/org.springframework.web/src/main/java/org/springframework/web/util/UrlPathHelper.java b/org.springframework.web/src/main/java/org/springframework/web/util/UrlPathHelper.java
index 65a167b..e54c3ae 100644
--- a/org.springframework.web/src/main/java/org/springframework/web/util/UrlPathHelper.java
+++ b/org.springframework.web/src/main/java/org/springframework/web/util/UrlPathHelper.java
@@ -1,400 +1,488 @@
-/*
- * Copyright 2002-2010 the original author or authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.springframework.web.util;
-
-import java.io.UnsupportedEncodingException;
-import java.net.URLDecoder;
-import java.util.Properties;
-import javax.servlet.http.HttpServletRequest;
-
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-
-import org.springframework.util.StringUtils;
-
-/**
- * Helper class for URL path matching. Provides support for URL paths in
- * RequestDispatcher includes and support for consistent URL decoding.
- *
- * <p>Used by {@link org.springframework.web.servlet.handler.AbstractUrlHandlerMapping},
- * {@link org.springframework.web.servlet.mvc.multiaction.AbstractUrlMethodNameResolver}
- * and {@link org.springframework.web.servlet.support.RequestContext} for path matching
- * and/or URI determination.
- *
- * @author Juergen Hoeller
- * @author Rob Harrop
- * @since 14.01.2004
- */
-public class UrlPathHelper {
-
-	/**
-	 * Special WebSphere request attribute, indicating the original request URI.
-	 * Preferable over the standard Servlet 2.4 forward attribute on WebSphere,
-	 * simply because we need the very first URI in the request forwarding chain.
-	 */
-	private static final String WEBSPHERE_URI_ATTRIBUTE = "com.ibm.websphere.servlet.uri_non_decoded";
-
-	private static final Log logger = LogFactory.getLog(UrlPathHelper.class);
-
-	static volatile Boolean websphereComplianceFlag;
-
-
-	private boolean alwaysUseFullPath = false;
-
-	private boolean urlDecode = true;
-
-	private String defaultEncoding = WebUtils.DEFAULT_CHARACTER_ENCODING;
-
-
-	/**
-	 * Set if URL lookup should always use full path within current servlet
-	 * context. Else, the path within the current servlet mapping is used
-	 * if applicable (i.e. in the case of a ".../*" servlet mapping in web.xml).
-	 * Default is "false".
-	 */
-	public void setAlwaysUseFullPath(boolean alwaysUseFullPath) {
-		this.alwaysUseFullPath = alwaysUseFullPath;
-	}
-
-	/**
-	 * Set if context path and request URI should be URL-decoded.
-	 * Both are returned <i>undecoded</i> by the Servlet API,
-	 * in contrast to the servlet path.
-	 * <p>Uses either the request encoding or the default encoding according
-	 * to the Servlet spec (ISO-8859-1).
-	 * <p>Default is "true", as of Spring 2.5.
-	 * @see #getServletPath
-	 * @see #getContextPath
-	 * @see #getRequestUri
-	 * @see WebUtils#DEFAULT_CHARACTER_ENCODING
-	 * @see javax.servlet.ServletRequest#getCharacterEncoding()
-	 * @see java.net.URLDecoder#decode(String, String)
-	 */
-	public void setUrlDecode(boolean urlDecode) {
-		this.urlDecode = urlDecode;
-	}
-
-	/**
-	 * Set the default character encoding to use for URL decoding.
-	 * Default is ISO-8859-1, according to the Servlet spec.
-	 * <p>If the request specifies a character encoding itself, the request
-	 * encoding will override this setting. This also allows for generically
-	 * overriding the character encoding in a filter that invokes the
-	 * <code>ServletRequest.setCharacterEncoding</code> method.
-	 * @param defaultEncoding the character encoding to use
-	 * @see #determineEncoding
-	 * @see javax.servlet.ServletRequest#getCharacterEncoding()
-	 * @see javax.servlet.ServletRequest#setCharacterEncoding(String)
-	 * @see WebUtils#DEFAULT_CHARACTER_ENCODING
-	 */
-	public void setDefaultEncoding(String defaultEncoding) {
-		this.defaultEncoding = defaultEncoding;
-	}
-
-	/**
-	 * Return the default character encoding to use for URL decoding.
-	 */
-	protected String getDefaultEncoding() {
-		return this.defaultEncoding;
-	}
-
-
-	/**
-	 * Return the mapping lookup path for the given request, within the current
-	 * servlet mapping if applicable, else within the web application.
-	 * <p>Detects include request URL if called within a RequestDispatcher include.
-	 * @param request current HTTP request
-	 * @return the lookup path
-	 * @see #getPathWithinApplication
-	 * @see #getPathWithinServletMapping
-	 */
-	public String getLookupPathForRequest(HttpServletRequest request) {
-		// Always use full path within current servlet context?
-		if (this.alwaysUseFullPath) {
-			return getPathWithinApplication(request);
-		}
-		// Else, use path within current servlet mapping if applicable
-		String rest = getPathWithinServletMapping(request);
-		if (!"".equals(rest)) {
-			return rest;
-		}
-		else {
-			return getPathWithinApplication(request);
-		}
-	}
-
-	/**
-	 * Return the path within the servlet mapping for the given request,
-	 * i.e. the part of the request's URL beyond the part that called the servlet,
-	 * or "" if the whole URL has been used to identify the servlet.
-	 * <p>Detects include request URL if called within a RequestDispatcher include.
-	 * <p>E.g.: servlet mapping = "/test/*"; request URI = "/test/a" -> "/a".
-	 * <p>E.g.: servlet mapping = "/test"; request URI = "/test" -> "".
-	 * <p>E.g.: servlet mapping = "/*.test"; request URI = "/a.test" -> "".
-	 * @param request current HTTP request
-	 * @return the path within the servlet mapping, or ""
-	 */
-	public String getPathWithinServletMapping(HttpServletRequest request) {
-		String pathWithinApp = getPathWithinApplication(request);
-		String servletPath = getServletPath(request);
-		if (pathWithinApp.startsWith(servletPath)) {
-			// Normal case: URI contains servlet path.
-			return pathWithinApp.substring(servletPath.length());
-		}
-		else {
-			// Special case: URI is different from servlet path.
-			// Can happen e.g. with index page: URI="/", servletPath="/index.html"
-			// Use path info if available, as it indicates an index page within
-			// a servlet mapping. Otherwise, use the full servlet path.
-			String pathInfo = request.getPathInfo();
-			return (pathInfo != null ? pathInfo : servletPath);
-		}
-	}
-
-	/**
-	 * Return the path within the web application for the given request.
-	 * <p>Detects include request URL if called within a RequestDispatcher include.
-	 * @param request current HTTP request
-	 * @return the path within the web application
-	 */
-	public String getPathWithinApplication(HttpServletRequest request) {
-		String contextPath = getContextPath(request);
-		String requestUri = getRequestUri(request);
-		if (StringUtils.startsWithIgnoreCase(requestUri, contextPath)) {
-			// Normal case: URI contains context path.
-			String path = requestUri.substring(contextPath.length());
-			return (StringUtils.hasText(path) ? path : "/");
-		}
-		else {
-			// Special case: rather unusual.
-			return requestUri;
-		}
-	}
-
-
-	/**
-	 * Return the request URI for the given request, detecting an include request
-	 * URL if called within a RequestDispatcher include.
-	 * <p>As the value returned by <code>request.getRequestURI()</code> is <i>not</i>
-	 * decoded by the servlet container, this method will decode it.
-	 * <p>The URI that the web container resolves <i>should</i> be correct, but some
-	 * containers like JBoss/Jetty incorrectly include ";" strings like ";jsessionid"
-	 * in the URI. This method cuts off such incorrect appendices.
-	 * @param request current HTTP request
-	 * @return the request URI
-	 */
-	public String getRequestUri(HttpServletRequest request) {
-		String uri = (String) request.getAttribute(WebUtils.INCLUDE_REQUEST_URI_ATTRIBUTE);
-		if (uri == null) {
-			uri = request.getRequestURI();
-		}
-		return decodeAndCleanUriString(request, uri);
-	}
-
-	/**
-	 * Return the context path for the given request, detecting an include request
-	 * URL if called within a RequestDispatcher include.
-	 * <p>As the value returned by <code>request.getContextPath()</code> is <i>not</i>
-	 * decoded by the servlet container, this method will decode it.
-	 * @param request current HTTP request
-	 * @return the context path
-	 */
-	public String getContextPath(HttpServletRequest request) {
-		String contextPath = (String) request.getAttribute(WebUtils.INCLUDE_CONTEXT_PATH_ATTRIBUTE);
-		if (contextPath == null) {
-			contextPath = request.getContextPath();
-		}
-		if ("/".equals(contextPath)) {
-			// Invalid case, but happens for includes on Jetty: silently adapt it.
-			contextPath = "";
-		}
-		return decodeRequestString(request, contextPath);
-	}
-
-	/**
-	 * Return the servlet path for the given request, regarding an include request
-	 * URL if called within a RequestDispatcher include.
-	 * <p>As the value returned by <code>request.getServletPath()</code> is already
-	 * decoded by the servlet container, this method will not attempt to decode it.
-	 * @param request current HTTP request
-	 * @return the servlet path
-	 */
-	public String getServletPath(HttpServletRequest request) {
-		String servletPath = (String) request.getAttribute(WebUtils.INCLUDE_SERVLET_PATH_ATTRIBUTE);
-		if (servletPath == null) {
-			servletPath = request.getServletPath();
-		}
-		if (servletPath.length() > 1 && servletPath.endsWith("/") &&
-				shouldRemoveTrailingServletPathSlash(request)) {
-			// On WebSphere, in non-compliant mode, for a "/foo/" case that would be "/foo"
-			// on all other servlet containers: removing trailing slash, proceeding with
-			// that remaining slash as final lookup path...
-			servletPath = servletPath.substring(0, servletPath.length() - 1);
-		}
-		return servletPath;
-	}
-
-
-	/**
-	 * Return the request URI for the given request. If this is a forwarded request,
-	 * correctly resolves to the request URI of the original request.
-	 */
-	public String getOriginatingRequestUri(HttpServletRequest request) {
-		String uri = (String) request.getAttribute(WEBSPHERE_URI_ATTRIBUTE);
-		if (uri == null) {
-			uri = (String) request.getAttribute(WebUtils.FORWARD_REQUEST_URI_ATTRIBUTE);
-			if (uri == null) {
-				uri = request.getRequestURI();
-			}
-		}
-		return decodeAndCleanUriString(request, uri);
-	}
-
-	/**
-	 * Return the context path for the given request, detecting an include request
-	 * URL if called within a RequestDispatcher include.
-	 * <p>As the value returned by <code>request.getContextPath()</code> is <i>not</i>
-	 * decoded by the servlet container, this method will decode it.
-	 * @param request current HTTP request
-	 * @return the context path
-	 */
-	public String getOriginatingContextPath(HttpServletRequest request) {
-		String contextPath = (String) request.getAttribute(WebUtils.FORWARD_CONTEXT_PATH_ATTRIBUTE);
-		if (contextPath == null) {
-			contextPath = request.getContextPath();
-		}
-		return decodeRequestString(request, contextPath);
-	}
-
-	/**
-	 * Return the servlet path for the given request, detecting an include request
-	 * URL if called within a RequestDispatcher include.
-	 * @param request current HTTP request
-	 * @return the servlet path
-	 */
-	public String getOriginatingServletPath(HttpServletRequest request) {
-		String servletPath = (String) request.getAttribute(WebUtils.FORWARD_SERVLET_PATH_ATTRIBUTE);
-		if (servletPath == null) {
-			servletPath = request.getServletPath();
-		}
-		return servletPath;
-	}
-
-	/**
-	 * Return the query string part of the given request's URL. If this is a forwarded request,
-	 * correctly resolves to the query string of the original request.
-	 * @param request current HTTP request
-	 * @return the query string
-	 */
-	public String getOriginatingQueryString(HttpServletRequest request) {
-		if ((request.getAttribute(WebUtils.FORWARD_REQUEST_URI_ATTRIBUTE) != null) || 
-			(request.getAttribute(WebUtils.ERROR_REQUEST_URI_ATTRIBUTE) != null)) {
-			return (String) request.getAttribute(WebUtils.FORWARD_QUERY_STRING_ATTRIBUTE);
-		}
-		else {
-			return request.getQueryString();
-		}
-	}
-
-	/**
-	 * Decode the supplied URI string and strips any extraneous portion after a ';'.
-	 */
-	private String decodeAndCleanUriString(HttpServletRequest request, String uri) {
-		uri = decodeRequestString(request, uri);
-		int semicolonIndex = uri.indexOf(';');
-		return (semicolonIndex != -1 ? uri.substring(0, semicolonIndex) : uri);
-	}
-
-	/**
-	 * Decode the given source string with a URLDecoder. The encoding will be taken
-	 * from the request, falling back to the default "ISO-8859-1".
-	 * <p>The default implementation uses <code>URLDecoder.decode(input, enc)</code>.
-	 * @param request current HTTP request
-	 * @param source the String to decode
-	 * @return the decoded String
-	 * @see WebUtils#DEFAULT_CHARACTER_ENCODING
-	 * @see javax.servlet.ServletRequest#getCharacterEncoding
-	 * @see java.net.URLDecoder#decode(String, String)
-	 * @see java.net.URLDecoder#decode(String)
-	 */
-	public String decodeRequestString(HttpServletRequest request, String source) {
-		if (this.urlDecode) {
-			String enc = determineEncoding(request);
-			try {
-				return UriUtils.decode(source, enc);
-			}
-			catch (UnsupportedEncodingException ex) {
-				if (logger.isWarnEnabled()) {
-					logger.warn("Could not decode request string [" + source + "] with encoding '" + enc +
-							"': falling back to platform default encoding; exception message: " + ex.getMessage());
-				}
-				return URLDecoder.decode(source);
-			}
-		}
-		return source;
-	}
-
-	/**
-	 * Determine the encoding for the given request.
-	 * Can be overridden in subclasses.
-	 * <p>The default implementation checks the request encoding,
-	 * falling back to the default encoding specified for this resolver.
-	 * @param request current HTTP request
-	 * @return the encoding for the request (never <code>null</code>)
-	 * @see javax.servlet.ServletRequest#getCharacterEncoding()
-	 * @see #setDefaultEncoding
-	 */
-	protected String determineEncoding(HttpServletRequest request) {
-		String enc = request.getCharacterEncoding();
-		if (enc == null) {
-			enc = getDefaultEncoding();
-		}
-		return enc;
-	}
-
-
-	private boolean shouldRemoveTrailingServletPathSlash(HttpServletRequest request) {
-		if (request.getAttribute(WEBSPHERE_URI_ATTRIBUTE) == null) {
-			// Regular servlet container: behaves as expected in any case,
-			// so the trailing slash is the result of a "/" url-pattern mapping.
-			// Don't remove that slash.
-			return false;
-		}
-		if (websphereComplianceFlag == null) {
-			ClassLoader classLoader = UrlPathHelper.class.getClassLoader();
-			String className = "com.ibm.ws.webcontainer.WebContainer";
-			String methodName = "getWebContainerProperties";
-			String propName = "com.ibm.ws.webcontainer.removetrailingservletpathslash";
-			boolean flag = false;
-			try {
-				Class<?> cl = classLoader.loadClass(className);
-				Properties prop = (Properties) cl.getMethod(methodName).invoke(null);
-				flag = Boolean.parseBoolean(prop.getProperty(propName));
-			}
-			catch (Throwable ex) {
-				if (logger.isDebugEnabled()) {
-					logger.debug("Could not introspect WebSphere web container properties: " + ex);
-				}
-			}
-			websphereComplianceFlag = flag;
-		}
-		// Don't bother if WebSphere is configured to be fully Servlet compliant.
-		// However, if it is not compliant, do remove the improper trailing slash!
-		return !websphereComplianceFlag;
-	}
-
-}
+/*
+ * Copyright 2002-2010 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.web.util;
+
+import java.io.UnsupportedEncodingException;
+import java.net.URLDecoder;
+import java.util.Properties;
+import javax.servlet.http.HttpServletRequest;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+
+import org.springframework.util.StringUtils;
+
+/**
+ * Helper class for URL path matching. Provides support for URL paths in
+ * RequestDispatcher includes and support for consistent URL decoding.
+ *
+ * <p>Used by {@link org.springframework.web.servlet.handler.AbstractUrlHandlerMapping},
+ * {@link org.springframework.web.servlet.mvc.multiaction.AbstractUrlMethodNameResolver}
+ * and {@link org.springframework.web.servlet.support.RequestContext} for path matching
+ * and/or URI determination.
+ *
+ * @author Juergen Hoeller
+ * @author Rob Harrop
+ * @since 14.01.2004
+ */
+public class UrlPathHelper {
+
+	/**
+	 * Special WebSphere request attribute, indicating the original request URI.
+	 * Preferable over the standard Servlet 2.4 forward attribute on WebSphere,
+	 * simply because we need the very first URI in the request forwarding chain.
+	 */
+	private static final String WEBSPHERE_URI_ATTRIBUTE = "com.ibm.websphere.servlet.uri_non_decoded";
+
+	private static final Log logger = LogFactory.getLog(UrlPathHelper.class);
+
+	static volatile Boolean websphereComplianceFlag;
+
+
+	private boolean alwaysUseFullPath = false;
+
+	private boolean urlDecode = true;
+	//20200921
+	private boolean removeSemicolonContent = true;
+
+	private String defaultEncoding = WebUtils.DEFAULT_CHARACTER_ENCODING;
+
+
+	/**
+	 * Set if URL lookup should always use full path within current servlet
+	 * context. Else, the path within the current servlet mapping is used
+	 * if applicable (i.e. in the case of a ".../*" servlet mapping in web.xml).
+	 * Default is "false".
+	 */
+	public void setAlwaysUseFullPath(boolean alwaysUseFullPath) {
+		this.alwaysUseFullPath = alwaysUseFullPath;
+	}
+
+	/**
+	 * Set if context path and request URI should be URL-decoded.
+	 * Both are returned <i>undecoded</i> by the Servlet API,
+	 * in contrast to the servlet path.
+	 * <p>Uses either the request encoding or the default encoding according
+	 * to the Servlet spec (ISO-8859-1).
+	 * <p>Default is "true", as of Spring 2.5.
+	 * @see #getServletPath
+	 * @see #getContextPath
+	 * @see #getRequestUri
+	 * @see WebUtils#DEFAULT_CHARACTER_ENCODING
+	 * @see javax.servlet.ServletRequest#getCharacterEncoding()
+	 * @see java.net.URLDecoder#decode(String, String)
+	 */
+	public void setUrlDecode(boolean urlDecode) {
+		this.urlDecode = urlDecode;
+	}
+	//20200921
+	/**
+	 * Set if ";" (semicolon) content should be stripped from the request URI.
+	 * <p>Default is "true".
+	 */
+	public void setRemoveSemicolonContent(boolean removeSemicolonContent) {
+		this.removeSemicolonContent = removeSemicolonContent;
+	}
+
+
+	/**
+	 * Set the default character encoding to use for URL decoding.
+	 * Default is ISO-8859-1, according to the Servlet spec.
+	 * <p>If the request specifies a character encoding itself, the request
+	 * encoding will override this setting. This also allows for generically
+	 * overriding the character encoding in a filter that invokes the
+	 * <code>ServletRequest.setCharacterEncoding</code> method.
+	 * @param defaultEncoding the character encoding to use
+	 * @see #determineEncoding
+	 * @see javax.servlet.ServletRequest#getCharacterEncoding()
+	 * @see javax.servlet.ServletRequest#setCharacterEncoding(String)
+	 * @see WebUtils#DEFAULT_CHARACTER_ENCODING
+	 */
+	public void setDefaultEncoding(String defaultEncoding) {
+		this.defaultEncoding = defaultEncoding;
+	}
+
+	/**
+	 * Return the default character encoding to use for URL decoding.
+	 */
+	protected String getDefaultEncoding() {
+		return this.defaultEncoding;
+	}
+
+
+	/**
+	 * Return the mapping lookup path for the given request, within the current
+	 * servlet mapping if applicable, else within the web application.
+	 * <p>Detects include request URL if called within a RequestDispatcher include.
+	 * @param request current HTTP request
+	 * @return the lookup path
+	 * @see #getPathWithinApplication
+	 * @see #getPathWithinServletMapping
+	 */
+	public String getLookupPathForRequest(HttpServletRequest request) {
+		// Always use full path within current servlet context?
+		if (this.alwaysUseFullPath) {
+			return getPathWithinApplication(request);
+		}
+		// Else, use path within current servlet mapping if applicable
+		String rest = getPathWithinServletMapping(request);
+		if (!"".equals(rest)) {
+			return rest;
+		}
+		else {
+			return getPathWithinApplication(request);
+		}
+	}
+
+	/**
+	 * Return the path within the servlet mapping for the given request,
+	 * i.e. the part of the request's URL beyond the part that called the servlet,
+	 * or "" if the whole URL has been used to identify the servlet.
+	 * <p>Detects include request URL if called within a RequestDispatcher include.
+	 * <p>E.g.: servlet mapping = "/test/*"; request URI = "/test/a" -> "/a".
+	 * <p>E.g.: servlet mapping = "/test"; request URI = "/test" -> "".
+	 * <p>E.g.: servlet mapping = "/*.test"; request URI = "/a.test" -> "".
+	 * @param request current HTTP request
+	 * @return the path within the servlet mapping, or ""
+	 */
+	public String getPathWithinServletMapping(HttpServletRequest request) {
+		String pathWithinApp = getPathWithinApplication(request);
+		String servletPath = getServletPath(request);
+		if (pathWithinApp.startsWith(servletPath)) {
+			// Normal case: URI contains servlet path.
+			return pathWithinApp.substring(servletPath.length());
+		}
+		else {
+			// Special case: URI is different from servlet path.
+			// Can happen e.g. with index page: URI="/", servletPath="/index.html"
+			// Use path info if available, as it indicates an index page within
+			// a servlet mapping. Otherwise, use the full servlet path.
+			String pathInfo = request.getPathInfo();
+			return (pathInfo != null ? pathInfo : servletPath);
+		}
+	}
+
+	/**
+	 * Return the path within the web application for the given request.
+	 * <p>Detects include request URL if called within a RequestDispatcher include.
+	 * @param request current HTTP request
+	 * @return the path within the web application
+	 */
+	public String getPathWithinApplication(HttpServletRequest request) {
+		String contextPath = getContextPath(request);
+		String requestUri = getRequestUri(request);
+		if (StringUtils.startsWithIgnoreCase(requestUri, contextPath)) {
+			// Normal case: URI contains context path.
+			String path = requestUri.substring(contextPath.length());
+			return (StringUtils.hasText(path) ? path : "/");
+		}
+		else {
+			// Special case: rather unusual.
+			return requestUri;
+		}
+	}
+
+
+	/**
+	 * Return the request URI for the given request, detecting an include request
+	 * URL if called within a RequestDispatcher include.
+	 * <p>As the value returned by <code>request.getRequestURI()</code> is <i>not</i>
+	 * decoded by the servlet container, this method will decode it.
+	 * <p>The URI that the web container resolves <i>should</i> be correct, but some
+	 * containers like JBoss/Jetty incorrectly include ";" strings like ";jsessionid"
+	 * in the URI. This method cuts off such incorrect appendices.
+	 * @param request current HTTP request
+	 * @return the request URI
+	 */
+	public String getRequestUri(HttpServletRequest request) {
+		String uri = (String) request.getAttribute(WebUtils.INCLUDE_REQUEST_URI_ATTRIBUTE);
+		if (uri == null) {
+			uri = request.getRequestURI();
+		}
+		return decodeAndCleanUriString(request, uri);
+	}
+
+	/**
+	 * Return the context path for the given request, detecting an include request
+	 * URL if called within a RequestDispatcher include.
+	 * <p>As the value returned by <code>request.getContextPath()</code> is <i>not</i>
+	 * decoded by the servlet container, this method will decode it.
+	 * @param request current HTTP request
+	 * @return the context path
+	 */
+	public String getContextPath(HttpServletRequest request) {
+		String contextPath = (String) request.getAttribute(WebUtils.INCLUDE_CONTEXT_PATH_ATTRIBUTE);
+		if (contextPath == null) {
+			contextPath = request.getContextPath();
+		}
+		if ("/".equals(contextPath)) {
+			// Invalid case, but happens for includes on Jetty: silently adapt it.
+			contextPath = "";
+		}
+		return decodeRequestString(request, contextPath);
+	}
+
+	/**
+	 * Return the servlet path for the given request, regarding an include request
+	 * URL if called within a RequestDispatcher include.
+	 * <p>As the value returned by <code>request.getServletPath()</code> is already
+	 * decoded by the servlet container, this method will not attempt to decode it.
+	 * @param request current HTTP request
+	 * @return the servlet path
+	 */
+	public String getServletPath(HttpServletRequest request) {
+		String servletPath = (String) request.getAttribute(WebUtils.INCLUDE_SERVLET_PATH_ATTRIBUTE);
+		if (servletPath == null) {
+			servletPath = request.getServletPath();
+		}
+		if (servletPath.length() > 1 && servletPath.endsWith("/") &&
+				shouldRemoveTrailingServletPathSlash(request)) {
+			// On WebSphere, in non-compliant mode, for a "/foo/" case that would be "/foo"
+			// on all other servlet containers: removing trailing slash, proceeding with
+			// that remaining slash as final lookup path...
+			servletPath = servletPath.substring(0, servletPath.length() - 1);
+		}
+		return servletPath;
+	}
+
+
+	/**
+	 * Return the request URI for the given request. If this is a forwarded request,
+	 * correctly resolves to the request URI of the original request.
+	 */
+	public String getOriginatingRequestUri(HttpServletRequest request) {
+		String uri = (String) request.getAttribute(WEBSPHERE_URI_ATTRIBUTE);
+		if (uri == null) {
+			uri = (String) request.getAttribute(WebUtils.FORWARD_REQUEST_URI_ATTRIBUTE);
+			if (uri == null) {
+				uri = request.getRequestURI();
+			}
+		}
+		return decodeAndCleanUriString(request, uri);
+	}
+
+	/**
+	 * Return the context path for the given request, detecting an include request
+	 * URL if called within a RequestDispatcher include.
+	 * <p>As the value returned by <code>request.getContextPath()</code> is <i>not</i>
+	 * decoded by the servlet container, this method will decode it.
+	 * @param request current HTTP request
+	 * @return the context path
+	 */
+	public String getOriginatingContextPath(HttpServletRequest request) {
+		String contextPath = (String) request.getAttribute(WebUtils.FORWARD_CONTEXT_PATH_ATTRIBUTE);
+		if (contextPath == null) {
+			contextPath = request.getContextPath();
+		}
+		return decodeRequestString(request, contextPath);
+	}
+
+	/**
+	 * Return the servlet path for the given request, detecting an include request
+	 * URL if called within a RequestDispatcher include.
+	 * @param request current HTTP request
+	 * @return the servlet path
+	 */
+	public String getOriginatingServletPath(HttpServletRequest request) {
+		String servletPath = (String) request.getAttribute(WebUtils.FORWARD_SERVLET_PATH_ATTRIBUTE);
+		if (servletPath == null) {
+			servletPath = request.getServletPath();
+		}
+		return servletPath;
+	}
+
+	/**
+	 * Return the query string part of the given request's URL. If this is a forwarded request,
+	 * correctly resolves to the query string of the original request.
+	 * @param request current HTTP request
+	 * @return the query string
+	 */
+	public String getOriginatingQueryString(HttpServletRequest request) {
+		if ((request.getAttribute(WebUtils.FORWARD_REQUEST_URI_ATTRIBUTE) != null) || 
+			(request.getAttribute(WebUtils.ERROR_REQUEST_URI_ATTRIBUTE) != null)) {
+			return (String) request.getAttribute(WebUtils.FORWARD_QUERY_STRING_ATTRIBUTE);
+		}
+		else {
+			return request.getQueryString();
+		}
+	}
+
+	/**
+	 * Decode the supplied URI string and strips any extraneous portion after a ';'.
+	 */
+	private String decodeAndCleanUriString(HttpServletRequest request, String uri) {
+//		uri = decodeRequestString(request, uri);
+//		int semicolonIndex = uri.indexOf(';');
+//		return (semicolonIndex != -1 ? uri.substring(0, semicolonIndex) : uri);
+		//20200921
+		uri = removeSemicolonContent(uri);
+		uri = decodeRequestString(request, uri);
+		return uri;
+	}
+
+//	/**
+//	 * Decode the given source string with a URLDecoder. The encoding will be taken
+//	 * from the request, falling back to the default "ISO-8859-1".
+//	 * <p>The default implementation uses <code>URLDecoder.decode(input, enc)</code>.
+//	 * @param request current HTTP request
+//	 * @param source the String to decode
+//	 * @return the decoded String
+//	 * @see WebUtils#DEFAULT_CHARACTER_ENCODING
+//	 * @see javax.servlet.ServletRequest#getCharacterEncoding
+//	 * @see java.net.URLDecoder#decode(String, String)
+//	 * @see java.net.URLDecoder#decode(String)
+//	 */
+//	public String decodeRequestString(HttpServletRequest request, String source) {
+//		if (this.urlDecode) {
+//			String enc = determineEncoding(request);
+//			try {
+//				return UriUtils.decode(source, enc);
+//			}
+//			catch (UnsupportedEncodingException ex) {
+//				if (logger.isWarnEnabled()) {
+//					logger.warn("Could not decode request string [" + source + "] with encoding '" + enc +
+//							"': falling back to platform default encoding; exception message: " + ex.getMessage());
+//				}
+//				return URLDecoder.decode(source);
+//			}
+//		}
+//		return source;
+//	}
+	
+	//20200921
+	/**
+	 * Decode the given source string with a URLDecoder. The encoding will be taken
+	 * from the request, falling back to the default "ISO-8859-1".
+	 * <p>The default implementation uses {@code URLDecoder.decode(input, enc)}.
+	 * @param request current HTTP request
+	 * @param source the String to decode
+	 * @return the decoded String
+	 * @see WebUtils#DEFAULT_CHARACTER_ENCODING
+	 * @see javax.servlet.ServletRequest#getCharacterEncoding
+	 * @see java.net.URLDecoder#decode(String, String)
+	 * @see java.net.URLDecoder#decode(String)
+	 */
+	public String decodeRequestString(HttpServletRequest request, String source) {
+		if (this.urlDecode && source != null) {
+			return decodeInternal(request, source);
+		}
+		return source;
+	}
+	
+	//20200921
+	@SuppressWarnings("deprecation")
+	private String decodeInternal(HttpServletRequest request, String source) {
+		String enc = determineEncoding(request);
+		try {
+			return UriUtils.decode(source, enc);
+		}
+		catch (UnsupportedEncodingException ex) {
+			if (logger.isWarnEnabled()) {
+				logger.warn("Could not decode request string [" + source + "] with encoding '" + enc +
+						"': falling back to platform default encoding; exception message: " + ex.getMessage());
+			}
+			return URLDecoder.decode(source);
+		}
+	}
+	
+	//20200921
+	/**
+	 * Remove ";" (semicolon) content from the given request URI if the
+	 * {@linkplain #setRemoveSemicolonContent(boolean) removeSemicolonContent}
+	 * property is set to "true". Note that "jssessionid" is always removed.
+	 * @param requestUri the request URI string to remove ";" content from
+	 * @return the updated URI string
+	 */
+	public String removeSemicolonContent(String requestUri) {
+//		return (this.removeSemicolonContent ?
+//				removeSemicolonContentInternal(requestUri) : removeJsessionid(requestUri));
+		return (this.removeSemicolonContent ? removeSemicolonContentInternal(requestUri) : requestUri);
+	}
+	//20200921
+	private String removeSemicolonContentInternal(String requestUri) {
+		int semicolonIndex = requestUri.indexOf(';');
+		while (semicolonIndex != -1) {
+			int slashIndex = requestUri.indexOf('/', semicolonIndex);
+			String start = requestUri.substring(0, semicolonIndex);
+			requestUri = (slashIndex != -1) ? start + requestUri.substring(slashIndex) : start;
+			semicolonIndex = requestUri.indexOf(';', semicolonIndex);
+		}
+		return requestUri;
+	}
+	//20200921
+//	private String removeJsessionid(String requestUri) {
+//		int startIndex = requestUri.toLowerCase().indexOf(";jsessionid=");
+//		if (startIndex != -1) {
+//			int endIndex = requestUri.indexOf(';', startIndex + 12);
+//			String start = requestUri.substring(0, startIndex);
+//			requestUri = (endIndex != -1) ? start + requestUri.substring(endIndex) : start;
+//		}
+//		return requestUri;
+//	}
+	
+	/**
+	 * Determine the encoding for the given request.
+	 * Can be overridden in subclasses.
+	 * <p>The default implementation checks the request encoding,
+	 * falling back to the default encoding specified for this resolver.
+	 * @param request current HTTP request
+	 * @return the encoding for the request (never <code>null</code>)
+	 * @see javax.servlet.ServletRequest#getCharacterEncoding()
+	 * @see #setDefaultEncoding
+	 */
+	protected String determineEncoding(HttpServletRequest request) {
+		String enc = request.getCharacterEncoding();
+		if (enc == null) {
+			enc = getDefaultEncoding();
+		}
+		return enc;
+	}
+
+	
+	
+
+	private boolean shouldRemoveTrailingServletPathSlash(HttpServletRequest request) {
+		if (request.getAttribute(WEBSPHERE_URI_ATTRIBUTE) == null) {
+			// Regular servlet container: behaves as expected in any case,
+			// so the trailing slash is the result of a "/" url-pattern mapping.
+			// Don't remove that slash.
+			return false;
+		}
+		if (websphereComplianceFlag == null) {
+			ClassLoader classLoader = UrlPathHelper.class.getClassLoader();
+			String className = "com.ibm.ws.webcontainer.WebContainer";
+			String methodName = "getWebContainerProperties";
+			String propName = "com.ibm.ws.webcontainer.removetrailingservletpathslash";
+			boolean flag = false;
+			try {
+				Class<?> cl = classLoader.loadClass(className);
+				Properties prop = (Properties) cl.getMethod(methodName).invoke(null);
+				flag = Boolean.parseBoolean(prop.getProperty(propName));
+			}
+			catch (Throwable ex) {
+				if (logger.isDebugEnabled()) {
+					logger.debug("Could not introspect WebSphere web container properties: " + ex);
+				}
+			}
+			websphereComplianceFlag = flag;
+		}
+		// Don't bother if WebSphere is configured to be fully Servlet compliant.
+		// However, if it is not compliant, do remove the improper trailing slash!
+		return !websphereComplianceFlag;
+	}
+
+}
-- 
1.8.3.1

